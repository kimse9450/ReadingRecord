7장 병렬 데이터 처리와 성능

- 스트림을 이용하면 순차 스트림을 병렬 스트림으로 자연스럽게 바꿀 수 있다.

7.1 병렬 스트림

- 병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림.

7.1.1 순차 스트림을 병렬 스트림으로 변환하기

- 순차 스트림에서 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산(숫자 합계 계산)이 병렬로 처리된다. 
- sequential로 병렬 스트림을 순차 스트림으로 바꿀 수 있다. 
- parallel과 sequential 두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다. 

7.1.2 스트림 성능 측정

    @Benchmark
    public long iterativeSum() {
    	long result = 0;
    	for (long i = 1L; i <= N; i++) {
    		result += i;
    	}
    	return result;
    }

- 벙렬 버전이 순차 버전에 비해 다섯 배나 느린 실망스러운 결과가 나옴.
- iterate 연산을 청크로 분할하기 어렵다. 
  - 리듀싱 과정을 시작하는 시점에서 전체 숫자 리스트가 준비되지 않았으므로 스트림을 병렬로 처리할 수 있도록 청크로 분할할 수 없다. 
  - 스트림이 병렬로 처리되도록 지시했고 각각의 합계가 다른 스레드에서 수행되었지만 결국 순차처리 방식과 크게 다른 점이 없으므로 스레드를 할당하는 오버헤드만 증가하게 된다. 
- 병렬화를 이용하려면 스트림을 재귀적으로 분할해야 하고, 각 서브 스트림을 서로 다른 스레드의 리듀싱 연산으로 할당하고, 이들 결과를 하나의 값으로 합쳐야 한다. 

7.1.3 병렬 스트림의 올바른 사용법

- 병렬 스트림이 올바로 동작하려면 공유된 가변 상태를 피해야 한다

7.1.4 병렬 스트림 효과적으로 사용하기

- 확신이 서지 않으면 직접 측정하라. 
- 박싱을 주의하라. 되도록이면 기본형 특화 스트림을 사용하는 것이 좋다. 
- 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다. 
  - Limit, findFirst처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 함.
  - indAny는 요소의 순서와 상관없이 연산하므로 findFirst보다 성능이 좋다. 
- 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라. 
- 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다. 
- 스트림을 구성하는 자료구조가 적절한지 확인하라. 
  - ArrayList를 LinkedList보다 효율적으로 분할할 수 있다. 
  - LinkedList를 탐색하려면 모든 요소들을 탐색해야 한다.
  - ArrayList는 요소를 탐색하지 않고도 리스트를 분할할 수 있다. 
- 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다. 
  - sized스트림은 정확히 같은 크기의 두 스트림으로 분할 할 수 있으므로 효과적으로 처리 가능.
  - 필터 연산은 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬 처리 할 수 있을지 알 수 없음.
- 최종 연산의 병합과정의 비용을 살펴보라. 

  소스             	분해성 
  ArrayList      	훌륭함 
  LinkedList     	나쁨  
  IntStream.range	훌륭함 
  Stream.iterate 	나쁨  
  HashSet        	훌륭함 
  TreeSet        	훌륭함 

7.2 포크/조인 프레임워크

- 포크/조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계.
- 포크/조인 프레임워크에서는 서브태스크를 스레드 풀(ForkJoinPool) 의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스 구현.

7.2.1 RecursiveTask 활용

    RecursiveTask<R>
    protected abstract R compute();
    
    if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) {
    	순차적으로 태스크 계산
    } else {
    	태스크를 두 서브태스크로 분할
    	태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함.
    	모든 서브 캐스트의 연산이 완료될 때까지 기다림
    	각 서브태스크의 결과를 합침.
    }

- 각각의 서브태스크의 크기가 충분히 작아질 때까지 태스크를 재귀적으로 포크함.
- 모든 서브태스크를 병렬로 수행
- 부분 결과를 조합

7.2.2 포크/조인 프레임워크를 제대로 사용하는 방법

- join 메서드를 태스크에 호출하면 태스크가 생산하는 결과가 준비될 때까지 호출을 블록시킨다. 따라서 두 서브 태스크가 모두 시작된 다음에 join을 호출해야 한다. 그렇지 않으면 각각의 서브태스크가 다른 태스크가 끝나길 기다리는 일이 발생. 
- RecursiveTask 내에서는 ForkJoinPool 의 invoke 메서드를 사용하지 말아야 한다. 대신 compute나 fork 메서드를 직접 호출할 수 있다. 
- 서브태스크에서 fork 메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다. 
- 포크/조인 프레임워크를 이용하는 병렬 계산은 디버깅하기 어렵다.
- 병렬 스크림에서 살펴본 것과 같이 멀티코어에 포크/조인 프레임워크를 사용하는 것은 순차 처리보다는 무조건 빠를 거라는 생각을 버려야 한다.

7.2.3 작업 훔치기

- 코어 개수와 관계 없이 적절한 크기로 분할된 많은 태스크를 포킹하는 것이 바람직하다. 
- 작업훔치기
  - ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다. 
  - 각각의 스레드는 자신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때마다 큐에서 다른 태스크를 가져와서 작업을 처리한다. 
  - 이때 한 스레드는 다른 스레드보다 자신에게 할당된 태스크를 더 빨리 처리할 수 있다. 
  - 즉, 다른 스레드는 바쁘게 일하고 있는데 한 스레드는 할일이 다 떨어진 상황이다. 
  - 이 때 할일이 없어진 스레드는 유휴 상태로 바뀌는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다. 
  - 모든 태스크가 작업을 끝낼 때까지, 즉 모든 큐가 빌 때까지 이 과정을 반복한다. 
  - 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업 부하를 비슷한 수준으로 유지할 수 있다. 

7.3 Spliterator 인터페이스

- Spliterator는 '분할할 수 있는 반복자'
- 병렬 작업에 특화되어있다. 

    public interface Spliterator<T> {
    	boolean tryAdvance(Consumer<? super T> action);
    	Spliterator<T> trySplit();
    	long setimateSize();
    	int characteristics();
    }

7.4 마치며

- 내부 반복을 이용하면 명시적으로 다른 스레드를 사용하지 않고도 스트림을 병렬로 처리할 수 있다. 
- 간단하게 스트림을 병렬로 처리할 수 있지만 항상 병렬 처리가 빠른 것은 아니다. 병렬 소프트웨어 동작 방법과 성능은 직관적이지 않을 때가 많으므로 병렬 처리를 사용했을 때 성능을 직접 측정해봐야 한다. 
- 병렬 스트림으로 데이터 집합을 병렬 실행할 때 특히 처리 해야 할 데이터가 아주 많거나 각 요소를 처리하는데 오랜 시간이 걸릴 때 성능을 높일 수 있다. 
- 가능하면 기본형 특화 스트림을 사용하는 등 올바른 자료구조 선택이 어떤 연산을 병렬로 처리하는 것보다 성능적으로 더 큰 영향을 미칠 수 있다.
- 포크/조인 프레임워크에서는 병렬화할 수 있는 태스크를 작은 태스크로 분할한 다음에 분할된 테스크를 각각의 스레드로 실행하며 서브태스크 각각의 결과를 합쳐서 최종 결과를 생성한다. 
- Spliterator는 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화 할 것인지 정의한다. 
